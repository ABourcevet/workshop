AWSTemplateFormatVersion: "2010-09-09"

Description: >
  Creates the SageMaker Studio Domain, default user and default app

Parameters:
  UserProfileName:
    Description: Name of studio user
    Type: String
    Default: DefaultUser

Resources:
  ####
  # Setup VPC, Subnet, IG and Routing Table ready for Studio
  ####
  VPC:
    Type: 'AWS::EC2::VPC'
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      Tags:
        - Key: VPC
          Value: NLP
        - Key: Name
          Value: NLP Lab 3.1 VPC
  InternetGateway1:
    Type: 'AWS::EC2::InternetGateway'
    DependsOn: VPC
  AttachGateway:
    Type: 'AWS::EC2::VPCGatewayAttachment'
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway1
  PublicSubnet:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.0.0/24
      AvailabilityZone: !Select
        - 0
        - !GetAZs
          Ref: AWS::Region
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: NLP Lab 3.1 Public Subnet
  PublicRouteTable1:
    Type: 'AWS::EC2::RouteTable'
    DependsOn:
      - AttachGateway
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: Public Route Table
  PublicRoute1:
    Type: 'AWS::EC2::Route'
    DependsOn:
      - VPC
      - AttachGateway
    Properties:
      RouteTableId: !Ref PublicRouteTable1
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway1
  PublicSubnet1RouteTableAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    Properties:
      SubnetId: !Ref PublicSubnet
      RouteTableId: !Ref PublicRouteTable1

  ####
  # Private Subet
  ####
  PrivateSubnet:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select
        - 0
        - !GetAZs
          Ref: AWS::Region
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: NLP Lab 3.1 Private Subnet
  PrivateRouteTable:
    Type: 'AWS::EC2::RouteTable'
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: Private Route Table 
  NAT:
   Type: AWS::EC2::NatGateway
   Properties:
      AllocationId:
         Fn::GetAtt:
         - EIP
         - AllocationId
      SubnetId:
         Ref: PublicSubnet
  EIP:
    Type: AWS::EC2::EIP
    Properties:
        Domain: vpc
  Route:
    Type: AWS::EC2::Route
    Properties:
        RouteTableId:
          Ref: PrivateRouteTable
        DestinationCidrBlock: 0.0.0.0/0
        NatGatewayId:
          Ref: NAT
  PrivateSubnetRouteTableAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    Properties:
      SubnetId: !Ref PrivateSubnet
      RouteTableId: !Ref PrivateRouteTable
  
  #########
  # Create custom resource to create studio domain
  #########

  LambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Path: /
  LambdaExecutionPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Path: /
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Sid: CreateServiceLinkedRole
            Effect: Allow
            Action:
              - iam:CreateServiceLinkedRole
            Resource: '*'
          - Sid: S3Permissions
            Effect: Allow
            Action:
              - s3:Get*
              - s3:List*
            Resource: '*'
          - Sid: NetworkPermissions
            Effect: Allow
            Action:
              - ec2:CreateNetworkInterface
              - ec2:AttachNetworkInterface
              - ec2:DescribeNetworkInterfaces
              - ec2:DeleteNetworkInterface
              - ec2:DetachNetworkInterface 
              - ec2:DescribeNetworkInterfaceAttribute
              - ec2:DescribeSecurityGroups
            Resource: '*'
          - Sid: EFSPermissions
            Effect: Allow
            Action:
              - elasticfilesystem:DescribeMountTargets
              - elasticfilesystem:DescribeMountTargetSecurityGroups
            Resource: '*'
          - Sid: CloudWatchLogsPermissions
            Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: !Sub "arn:${AWS::Partition}:logs:*:*:*"
          - Sid: SageMakerDomainPermission
            Effect: Allow
            Action:
              - sagemaker:CreateDomain
              - sagemaker:DescribeDomain
              - sagemaker:DeleteDomain
              - sagemaker:UpdateDomain
              - sagemaker:CreateUserProfile
              - sagemaker:UpdateUserProfile
              - sagemaker:DeleteUserProfile
              - sagemaker:DescribeUserProfile
              - sagemaker:CreateApp
              - sagemaker:DescribeApp
              - sagemaker:DeleteApp
            Resource:
              - !Sub "arn:${AWS::Partition}:sagemaker:*:*:domain/*"
              - !Sub "arn:${AWS::Partition}:sagemaker:*:*:user-profile/*"
              - !Sub "arn:${AWS::Partition}:sagemaker:*:*:app/*"
          - Sid: SageMakerExecPassRole
            Effect: Allow
            Action:
              - iam:PassRole
            Resource: !GetAtt  SageMakerExecutionRole.Arn
      Roles:
        - !Ref  LambdaExecutionRole

  SageMakerExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - sagemaker.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSageMakerFullAccess

  StudioDomainFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import time
          import boto3
          import logging
          import cfnresponse
          from botocore.exceptions import ClientError
          client = boto3.client('sagemaker')
          def lambda_handler(event, context):
            try:
              if event['RequestType'] == 'Create':
                handle_create(event, context)
              elif event['RequestType'] == 'Update':
                handle_update(event, context)
              elif event['RequestType'] == 'Delete':
                handle_delete(event, context)
            except ClientError as exception:
                print(exception)
                logging.error(exception)
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, error=str(exception))
          def handle_create(event, context):
            resource_config = event['ResourceProperties']
            response_data = create_studio_domain(resource_config)
            efs_client = boto3.client('efs')
            efs_response = efs_client.describe_mount_targets(FileSystemId=response_data['HomeEfsFileSystemId'])
            sg_response = efs_client.describe_mount_target_security_groups(MountTargetId = efs_response['MountTargets'][0]['MountTargetId'])
            ec2_client = boto3.client('ec2')
            ec2_response = ec2_client.describe_security_groups(GroupIds=sg_response['SecurityGroups'])
            e = ec2_response['SecurityGroups'][0]['IpPermissions'][0]['UserIdGroupPairs'][0]['GroupId']
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {'DomainId': response_data['DomainId'],'EFSId':response_data['HomeEfsFileSystemId'], 'SG':e}, physicalResourceId=response_data['DomainId'])
          def handle_delete(event, context):
            print('Received delete event')
            domain_id = event['PhysicalResourceId']
            try:
              client.describe_domain(DomainId=domain_id)
            except ClientError as exception:
              logging.error(exception)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, physicalResourceId=event['PhysicalResourceId'])
              return
            delete_domain(domain_id)
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, physicalResourceId=event['PhysicalResourceId'])
          def handle_update(event, context):
            logging.info('Received Update event')
            domain_id = event['PhysicalResourceId']
            default_user_settings = event['ResourceProperties']['DefaultUserSettings']
            update_domain(domain_id, default_user_settings)
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {'DomainId' : domain_id}, physicalResourceId=event['PhysicalResourceId'])
          def create_studio_domain(config):
            vpc_id = config['VPC']
            subnet_ids = config['SubnetIds']
            default_user_settings = config['DefaultUserSettings']
            domain_name = config['DomainName']
            response = client.create_domain(
              DomainName=domain_name,
              AuthMode='IAM',
              DefaultUserSettings=default_user_settings,
              SubnetIds=subnet_ids.split(','),
              VpcId=vpc_id
            )
            domain_id = response['DomainArn'].split('/')[-1]
            created = False
            while not created:
              response = client.describe_domain(DomainId=domain_id)
              time.sleep(5)
              if response['Status'] == 'InService':
                created = True
            return response
          def delete_domain(domain_id):
            response = client.delete_domain(DomainId=domain_id, RetentionPolicy={'HomeEfsFileSystem': 'Delete'})
            print(response)
            deleted = False
            while not deleted:
              try:
                response = client.describe_domain(DomainId=domain_id)
                print(response)
              except ClientError as error:
                print(error)
                if error.response['Error']['Code'] == 'ResourceNotFound':
                  print('Deleted')
                  deleted = True
                  return
              time.sleep(5)
            return response
          def update_domain(domain_id, default_user_settings):
            response = client.update_domain(
              DomainId=domain_id,
              DefaultUserSettings=default_user_settings
            )
            updated = False
            while not updated:
              response = client.describe_domain(DomainId=domain_id)
              if response['Status'] == 'InService':
                updated = True
              else:
                logging.info('Updating .. %s', response['Status'])
              time.sleep(5)
            return response
      Runtime: python3.8
      Timeout: 900
    DependsOn:
      - LambdaExecutionPolicy

  UserProfileFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import time
          import boto3
          import logging
          import cfnresponse
          from botocore.exceptions import ClientError
          client = boto3.client('sagemaker')
          def lambda_handler(event, context):
              try:
                  if event['RequestType'] == 'Create':
                      handle_create(event, context)
                  elif event['RequestType'] == 'Update':
                      handle_update(event, context)
                  elif event['RequestType'] == 'Delete':
                      handle_delete(event, context)
              except ClientError as exception:
                  logging.error(exception)
                  cfnresponse.send(event, context, cfnresponse.FAILED,
                                  {}, error=str(exception))
          def handle_create(event, context):
              resource_config = event['ResourceProperties']
              response_data = create_user_profile(resource_config)
              cfnresponse.send(event, context, cfnresponse.SUCCESS,
                              {'UserProfileName': response_data['UserProfileName']}, physicalResourceId=response_data['UserProfileName'])
          def handle_delete(event, context):
              user_profile_name = event['PhysicalResourceId']
              domain_id = event['ResourceProperties']['DomainId']
              try:
                  client.describe_user_profile(DomainId=domain_id, UserProfileName=user_profile_name)
                  delete_user_profile(domain_id, user_profile_name)
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {},physicalResourceId=event['PhysicalResourceId'])
              except ClientError as e:
                  print(e)
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, physicalResourceId=event['PhysicalResourceId'])
              return
          def handle_update(event, context):
              user_profile_name = event['PhysicalResourceId']
              domain_id = event['ResourceProperties']['DomainId']
              user_settings = event['ResourceProperties']['UserSettings']
              update_user_profile(domain_id, user_profile_name, user_settings)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {},
                              physicalResourceId=event['PhysicalResourceId'])
          def create_user_profile(config):
              domain_id = config['DomainId']
              user_profile_name = config['UserProfileName']
              user_settings = config['UserSettings']
              response = client.create_user_profile(
                  DomainId=domain_id,
                  UserProfileName=user_profile_name,
                  UserSettings=user_settings,
              )
              created = False
              while not created:
                  response = client.describe_user_profile(DomainId=domain_id, UserProfileName=user_profile_name)
                  time.sleep(5)
                  if response['Status'] == 'InService':
                      created = True
              return response
          def delete_user_profile(domain_id, user_profile_name):
              response = client.delete_user_profile(
                  DomainId=domain_id,
                  UserProfileName=user_profile_name
              )
              print(response)
              deleted = False
              while not deleted:
                  time.sleep(5)
                  response = client.describe_user_profile(DomainId=domain_id, UserProfileName=user_profile_name)
                  if response is not None and 'Status' in response and response['Status'] == 'Deleted':
                      deleted = True
              return 
          def update_user_profile(domain_id, user_profile_name, user_settings):
              response = client.update_user_profile(
                  DomainId=domain_id,
                  UserProfileName=user_profile_name,
                  UserSettings=user_settings
              )
              updated = False
              while not updated:
                  response = client.describe_user_profile(DomainId=domain_id,UserProfileName=user_profile_name)
                  if response['Status'] == 'InService':
                      updated = True
                  else:
                      time.sleep(5)
              return response      
      Runtime: python3.8
      Timeout: 900
    DependsOn:
      - LambdaExecutionPolicy

  AppFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.8
      Code:
        ZipFile: |
          import json
          import time
          import boto3
          import logging
          import cfnresponse
          from botocore.exceptions import ClientError
          client = boto3.client('sagemaker')
          def lambda_handler(event, context):
              try:
                  if event['RequestType'] == 'Create':
                      handle_create(event, context)
                  elif event['RequestType'] == 'Update':
                      handle_update(event, context)
                  elif event['RequestType'] == 'Delete':
                      handle_delete(event, context)
              except ClientError as exception:
                  logging.error(exception)
                  cfnresponse.send(event, context, cfnresponse.FAILED,
                                  {}, error=str(exception))
          def handle_create(event, context):
              resource_config = event['ResourceProperties']
              response_data = create_app(resource_config)
              cfnresponse.send(event, context, cfnresponse.SUCCESS,
                              {'AppName': response_data['AppName']}, physicalResourceId=response_data['AppName'])
          def handle_delete(event, context):
              app_name=event['PhysicalResourceId']
              domain_id = event['ResourceProperties']['DomainId']
              app_type=event['ResourceProperties']['AppType']
              user_profile_name=event['ResourceProperties']['UserProfileName']
              try:
                  client.describe_app(DomainId=domain_id, UserProfileName=user_profile_name, AppType=app_type, AppName=app_name)
                  response = client.delete_app(
                      DomainId=domain_id,
                      UserProfileName=user_profile_name,
                      AppType=app_type,
                      AppName=app_name
                  )
                  deleted = False
                  while not deleted:
                      time.sleep(5)
                      response = client.describe_app(DomainId=domain_id, UserProfileName=user_profile_name, AppType=app_type, AppName=app_name)
                      print(response)
                      if response is not None and 'Status' in response and response['Status'] == 'Deleted':
                          deleted = True
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, physicalResourceId=app_name)
              except ClientError:
                  cfnresponse.send(event, context,cfnresponse.SUCCESS, {}, physicalResourceId=app_name)
              return
          def handle_update(event, context):
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {},
                              physicalResourceId=event['PhysicalResourceId'])
          def create_app(config):
              domain_id = config['DomainId']
              user_profile_name = config['UserProfileName']
              app_name = config['AppName']
              app_type = config['AppType']
              response = client.create_app(
                  DomainId=domain_id,
                  UserProfileName=user_profile_name,
                  AppType=app_type,
                  AppName=app_name
              )
              created = False
              while not created:
                  response = client.describe_app(DomainId=domain_id, UserProfileName=user_profile_name, AppType=app_type, AppName=app_name)
                  time.sleep(5)
                  if response['Status'] == 'InService':
                      created=True
              return response
      Timeout: 900
    DependsOn:
      - LambdaExecutionPolicy

  DownloadNotebooksFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Code: 
        ZipFile: | 
          import json
          import os
          import boto3
          import math
          import time
          import cfnresponse
          import logging
          from botocore.exceptions import ClientError
          def download_dir(prefix, local, bucket, region):
            client = boto3.client('s3',region_name='us-west-2')
            paginator = client.get_paginator('list_objects')
            operation_parameters = {'Bucket': bucket, 'Prefix': prefix}
            keys = []
            dirs = []
            page_iterator = paginator.paginate(**operation_parameters)
            
            for page in page_iterator:
              for content in page['Contents']:
                k = content['Key']
                if k[-1] != '/':
                  keys.append(k)
                else:
                  dirs.append(k)
            for d in dirs:
              dest_pathname = os.path.join(local, d).replace(prefix,'')
              if not os.path.exists(os.path.dirname(dest_pathname)):
                os.makedirs(os.path.dirname(dest_pathname))
            for k in keys:
              dest_pathname = os.path.join(local, k)
              dest_pathname = dest_pathname.replace(prefix,'')
              if not os.path.exists(os.path.dirname(dest_pathname)):  
                os.makedirs(os.path.dirname(dest_pathname))
              client.download_file(bucket, k, dest_pathname)


          def handle_create(event, context):
            resource_config = event['ResourceProperties']
            prefix = resource_config['Prefix']
            target = resource_config['Target']
            bucket = resource_config['S3Bucket']
            region = resource_config['BucketRegion']
            print(f'calling download_dir {prefix}, {target}, {bucket}, {region}')
            download_dir(prefix, target, bucket, region)

          def lambda_handler(event, context):
            print(event)
            print(context)
            try:
              if event['RequestType'] == 'Create':
                handle_create(event, context)
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, physicalResourceId='12345678')
              if event['RequestType'] == 'Delete':
                time.sleep(5)
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, physicalResourceId=event['PhysicalResourceId'])
              else:
                time.sleep(5)
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, physicalResourceId='12345678')
            except ClientError as exception:
              logging.error(exception)
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, error=str(exception))

      Description: Copies notebook files into EFS filesystem created by studio
      FileSystemConfigs:
        - Arn: !GetAtt LabEFS.Arn
          LocalMountPath: '/mnt/studio'
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.8
      Timeout: 300
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSG
          - !GetAtt StudioDomain.SG
        SubnetIds:
          - !Ref PrivateSubnet
  
  StudioDomain:
    Type: Custom::StudioDomain
    Properties:
      ServiceToken: !GetAtt StudioDomainFunction.Arn
      VPC: !Ref VPC
      SubnetIds: !Ref PublicSubnet
      DomainName: "MyDomainName"
      DefaultUserSettings:
        ExecutionRole: !GetAtt SageMakerExecutionRole.Arn

  UserProfile:
    Type: Custom::UserProfile
    Properties:
      ServiceToken: !GetAtt UserProfileFunction.Arn
      DomainId: !GetAtt StudioDomain.DomainId
      UserProfileName: !Ref UserProfileName
      UserSettings:
        ExecutionRole: !GetAtt SageMakerExecutionRole.Arn

  DefaultApp:
    Type: Custom::App
    Properties:
      ServiceToken: !GetAtt AppFunction.Arn
      DomainId: !GetAtt StudioDomain.DomainId
      UserProfileName: !GetAtt UserProfile.UserProfileName
      AppName: default
      AppType: JupyterServer
      UserSettings:
        ExecutionRole: !GetAtt SageMakerExecutionRole.Arn

  CopyNotebooks:
    Type: Custom::DownloadNotebooksFunction
    Properties:
      ServiceToken: !GetAtt DownloadNotebooksFunction.Arn
      Prefix: 'CUR-TF-200-ACMNLP-1/202012'
      Target: '/mnt/studio/200005'
      S3Bucket: 'aws-tc-largeobjects'
      BucketRegion: 'us-west-2'
    DependsOn:
      - DefaultApp
      - NAT
      - PrivateSubnetRouteTableAssociation
      - PublicSubnet1RouteTableAssociation
      - PublicRoute1
      - Route

  LabBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Join ["-", ["sagemaker-nlp-lab", !Ref "AWS::AccountId"]]

  LabEFS:
    Type: "AWS::EFS::AccessPoint"
    Properties:
      ClientToken: !GetAtt StudioDomain.DomainId
      FileSystemId: !GetAtt StudioDomain.EFSId
      PosixUser:
        Gid: "0"
        Uid: "0"

  LambdaSG:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupDescription: Allow Lambda outbound traffic
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      VpcId: !Ref VPC
  

Outputs:
  LabAccountId:
    Value: !Ref "AWS::AccountId"
  LabRegion:
    Value: !Ref "AWS::Region"
  LabBucket:
    Value: !Ref "LabBucket"

