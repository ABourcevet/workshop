AWSTemplateFormatVersion: "2010-09-09"

Description: >
  Creates the SageMaker Studio Domain, default user and default app

Parameters:
  UserProfileName:
    Description: Name of studio user
    Type: String
    Default: DefaultUser

Resources:
  ####
  # Setup VPC, Subnet, IG and Routing Table ready for Studio
  ####
  VPC:
    Type: 'AWS::EC2::VPC'
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      Tags:
        - Key: VPC
          Value: VPC
        - Key: Name
          Value: VPC
  InternetGateway1:
    Type: 'AWS::EC2::InternetGateway'
    DependsOn: VPC
  AttachGateway:
    Type: 'AWS::EC2::VPCGatewayAttachment'
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway1
  PublicSubnet:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.0.0/24
      AvailabilityZone: !Select
        - 0 
        - !GetAZs
          Ref: AWS::Region
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: Public Subnet
  PublicRouteTable1:
    Type: 'AWS::EC2::RouteTable'
    DependsOn:
      - AttachGateway
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: Public Route Table
  PublicRoute1:
    Type: 'AWS::EC2::Route'
    DependsOn:
      - VPC
      - AttachGateway
    Properties:
      RouteTableId: !Ref PublicRouteTable1
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway1
  PublicSubnet1RouteTableAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    Properties:
      SubnetId: !Ref PublicSubnet
      RouteTableId: !Ref PublicRouteTable1

  ####
  # Private Subet
  ####
  PrivateSubnet:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select
        - 0
        - !GetAZs
          Ref: AWS::Region
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: Private Subnet
  PrivateRouteTable:
    Type: 'AWS::EC2::RouteTable'
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: Private Route Table 
  NAT:
   Type: AWS::EC2::NatGateway
   Properties:
      AllocationId:
         Fn::GetAtt:
         - EIP
         - AllocationId
      SubnetId:
         Ref: PublicSubnet
  EIP:
    Type: AWS::EC2::EIP
    Properties:
        Domain: vpc
  Route:
    Type: AWS::EC2::Route
    Properties:
        RouteTableId:
          Ref: PrivateRouteTable
        DestinationCidrBlock: 0.0.0.0/0
        NatGatewayId:
          Ref: NAT
  PrivateSubnetRouteTableAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    Properties:
      SubnetId: !Ref PrivateSubnet
      RouteTableId: !Ref PrivateRouteTable
  
  #########
  # Create custom resource to create studio domain
  #########

  LambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Path: /
  LambdaExecutionPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Path: /
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Sid: CreateServiceLinkedRole
            Effect: Allow
            Action:
              - iam:CreateServiceLinkedRole
            Resource: '*'
          - Sid: S3Permissions
            Effect: Allow
            Action:
              - s3:Get*
              - s3:List*
            Resource: '*'
          - Sid: NetworkPermissions
            Effect: Allow
            Action:
              - ec2:CreateNetworkInterface
              - ec2:AttachNetworkInterface
              - ec2:DescribeNetworkInterfaces
              - ec2:DeleteNetworkInterface
              - ec2:DetachNetworkInterface 
              - ec2:DescribeNetworkInterfaceAttribute
              - ec2:DescribeSecurityGroups
              - ec2:DescribeSubnets
              - ec2:DescribeVpcs
            Resource: '*'
          - Sid: EFSPermissions
            Effect: Allow
            Action:
              - elasticfilesystem:DescribeMountTargets
              - elasticfilesystem:DescribeMountTargetSecurityGroups
              - elasticfilesystem:ClientMount
              - elasticfilesystem:ClientWrite
            Resource: '*'
          - Sid: CloudWatchLogsPermissions
            Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: !Sub "arn:${AWS::Partition}:logs:*:*:*"
          - Sid: SageMakerDomainPermission
            Effect: Allow
            Action:
              - sagemaker:CreateDomain
              - sagemaker:DescribeDomain
              - sagemaker:DeleteDomain
              - sagemaker:UpdateDomain
              - sagemaker:CreateUserProfile
              - sagemaker:UpdateUserProfile
              - sagemaker:DeleteUserProfile
              - sagemaker:DescribeUserProfile
              - sagemaker:CreateApp
              - sagemaker:DescribeApp
              - sagemaker:DeleteApp
              - sagemaker:ListApps
              - sagemaker:ListUserProfiles
            Resource:
              - !Sub "arn:${AWS::Partition}:sagemaker:*:*:domain/*"
              - !Sub "arn:${AWS::Partition}:sagemaker:*:*:user-profile/*"
              - !Sub "arn:${AWS::Partition}:sagemaker:*:*:app/*"
          - Sid: SageMakerExecPassRole
            Effect: Allow
            Action:
              - iam:PassRole
            Resource: !GetAtt  SageMakerExecutionRole.Arn
      Roles:
        - !Ref  LambdaExecutionRole

  SageMakerExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - sagemaker.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Path: /service-role/ 
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSageMakerFullAccess
        - arn:aws:iam::aws:policy/AmazonAthenaFullAccess
        - arn:aws:iam::aws:policy/AmazonSageMakerFeatureStoreAccess
        - arn:aws:iam::aws:policy/AmazonRedshiftFullAccess
        - arn:aws:iam::aws:policy/AWSStepFunctionsFullAccess
        - arn:aws:iam::aws:policy/AmazonKinesisFullAccess
        - arn:aws:iam::aws:policy/AmazonKinesisFirehoseFullAccess
        - arn:aws:iam::aws:policy/AmazonKinesisAnalyticsFullAccess

  SageMakerExecutionPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Path: /
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Sid: S3Permissions
            Effect: Allow
            Action:
              - s3:Get*
              - s3:List*
            Resource: '*'
          - Sid: IAMPermissions
            Effect: Allow
            Action:
              - iam:GetRole
            Resource: '*'
      Roles:
        - !Ref  SageMakerExecutionRole

  StudioDomainFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import time
          import boto3
          import logging
          import cfnresponse
          from botocore.exceptions import ClientError
          client = boto3.client('sagemaker')
          def lambda_handler(event, context):
            try:
              if event['RequestType'] == 'Create':
                handle_create(event, context)
              elif event['RequestType'] == 'Update':
                handle_update(event, context)
              elif event['RequestType'] == 'Delete':
                handle_delete(event, context)
            except ClientError as exception:
                print(exception)
                logging.error(exception)
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, error=str(exception))
          def handle_create(event, context):
            resource_config = event['ResourceProperties']
            response_data = create_studio_domain(resource_config)
            efs_client = boto3.client('efs')
            efs_response = efs_client.describe_mount_targets(FileSystemId=response_data['HomeEfsFileSystemId'])
            sg_response = efs_client.describe_mount_target_security_groups(MountTargetId = efs_response['MountTargets'][0]['MountTargetId'])
            ec2_client = boto3.client('ec2')
            ec2_response = ec2_client.describe_security_groups(GroupIds=sg_response['SecurityGroups'])
            e = ec2_response['SecurityGroups'][0]['IpPermissions'][0]['UserIdGroupPairs'][0]['GroupId']
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {'DomainId': response_data['DomainId'],'EFSId':response_data['HomeEfsFileSystemId'], 'SG':e}, physicalResourceId=response_data['DomainId'])
          def handle_delete(event, context):
            print('Received delete event')
            domain_id = event['PhysicalResourceId']
            try:
              client.describe_domain(DomainId=domain_id)
            except ClientError as exception:
              logging.error(exception)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, physicalResourceId=event['PhysicalResourceId'])
              return
            delete_domain(domain_id)
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, physicalResourceId=event['PhysicalResourceId'])
          def handle_update(event, context):
            logging.info('Received Update event')
            domain_id = event['PhysicalResourceId']
            default_user_settings = event['ResourceProperties']['DefaultUserSettings']
            update_domain(domain_id, default_user_settings)
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {'DomainId' : domain_id}, physicalResourceId=event['PhysicalResourceId'])
          def create_studio_domain(config):
            vpc_id = config['VPC']
            subnet_ids = config['SubnetIds']
            default_user_settings = config['DefaultUserSettings']
            domain_name = config['DomainName']
            response = client.create_domain(
              DomainName=domain_name,
              AuthMode='IAM',
              DefaultUserSettings=default_user_settings,
              SubnetIds=subnet_ids.split(','),
              VpcId=vpc_id
            )
            domain_id = response['DomainArn'].split('/')[-1]
            created = False
            while not created:
              response = client.describe_domain(DomainId=domain_id)
              time.sleep(5)
              if response['Status'] == 'InService':
                created = True
            return response
          def delete_domain(domain_id):
            response = client.delete_domain(DomainId=domain_id, RetentionPolicy={'HomeEfsFileSystem': 'Delete'})
            print(response)
            deleted = False
            while not deleted:
              try:
                response = client.describe_domain(DomainId=domain_id)
                print(response)
              except ClientError as error:
                print(error)
                if error.response['Error']['Code'] == 'ResourceNotFound':
                  print('Deleted')
                  deleted = True
                  return
              time.sleep(5)
            return response
          def update_domain(domain_id, default_user_settings):
            response = client.update_domain(
              DomainId=domain_id,
              DefaultUserSettings=default_user_settings
            )
            updated = False
            while not updated:
              response = client.describe_domain(DomainId=domain_id)
              if response['Status'] == 'InService':
                updated = True
              else:
                logging.info('Updating .. %s', response['Status'])
              time.sleep(5)
            return response
      Runtime: python3.8
      Timeout: 900
    DependsOn:
      - LambdaExecutionPolicy

  UserProfileFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import time, logging
          import boto3
          import cfnresponse
          from botocore.exceptions import ClientError
          client = boto3.client('sagemaker')
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
            logger.info(f'event: {event}')
            try:
              if event['RequestType'] == 'Create':
                handle_create(event, context)
              elif event['RequestType'] == 'Update':
                handle_update(event, context)
              elif event['RequestType'] == 'Delete':
                handle_delete(event, context)
            except Exception as exp:
              logger.exception(exp)
              cfnresponse.send(event, context, cfnresponse.FAILED,{}, reason=str(exp))
          def handle_create(event, context):
            resource_config = event['ResourceProperties']
            response_data = create_user_profile(resource_config)
            cfnresponse.send(event, context, cfnresponse.SUCCESS,{'UserProfileName': response_data['UserProfileName']}, physicalResourceId=response_data['UserProfileName'])
          def handle_delete(event, context):
            user_profile_name = event['PhysicalResourceId']
            domain_id = event['ResourceProperties']['DomainId']
            paginator = client.get_paginator('list_user_profiles')
            page_iterator = paginator.paginate(DomainIdEquals=domain_id)
            for page in page_iterator:
              for user_profile in page['UserProfiles']:
                logger.info(f'Deleting user {user_profile}')
                delete_user_profile(domain_id, user_profile['UserProfileName'])
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {},physicalResourceId=event['PhysicalResourceId'])
            return
          def handle_update(event, context):
            user_profile_name = event['PhysicalResourceId']
            domain_id = event['ResourceProperties']['DomainId']
            user_settings = event['ResourceProperties']['UserSettings']
            update_user_profile(domain_id, user_profile_name, user_settings)
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {},physicalResourceId=event['PhysicalResourceId'])
          def create_user_profile(config):
            domain_id = config['DomainId']
            user_profile_name = config['UserProfileName']
            user_settings = config['UserSettings']
            response = client.create_user_profile(DomainId=domain_id, UserProfileName=user_profile_name,UserSettings=user_settings)
            created = False
            while not created:
              response = client.describe_user_profile(DomainId=domain_id, UserProfileName=user_profile_name)
              time.sleep(5)
              if response['Status'] == 'InService':
                created = True
            return response
          def delete_user_profile(domain_id, user_profile_name):
            response = client.delete_user_profile(DomainId=domain_id, UserProfileName=user_profile_name)
            logger.info(response)
            deleted = False
            while not deleted:
              time.sleep(5)
              try:
                response = client.describe_user_profile(DomainId=domain_id, UserProfileName=user_profile_name)
                if response is not None and 'Status' in response and response['Status'] == 'Deleted':
                  deleted = True
              except:
                deleted = True
            return 
          def update_user_profile(domain_id, user_profile_name, user_settings):
            response = client.update_user_profile(DomainId=domain_id, UserProfileName=user_profile_name, UserSettings=user_settings)
            updated = False
            while not updated:
              response = client.describe_user_profile(DomainId=domain_id,UserProfileName=user_profile_name)
              if response['Status'] == 'InService':
                updated = True
              else:
                time.sleep(5)
            return response  
      Runtime: python3.8
      Timeout: 900
    DependsOn:
      - LambdaExecutionPolicy

  AppFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.8
      Code:
        ZipFile: |
          import time, logging
          import boto3
          import cfnresponse
          client = boto3.client('sagemaker')
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info(f'event: {event}')
              try:
                  if event['RequestType'] == 'Create':
                      handle_create(event, context)
                  elif event['RequestType'] == 'Update':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, physicalResourceId=event['PhysicalResourceId'])
                  elif event['RequestType'] == 'Delete':
                      handle_delete(event, context)
              except Exception as exp:
                  logger.exception(exp)
                  cfnresponse.send(event, context, cfnresponse.FAILED,{}, reason=str(exp))
          def handle_create(event, context):
              response_data = create_app(event['ResourceProperties'])
              cfnresponse.send(event, context, cfnresponse.SUCCESS,{'AppName': response_data['AppName']}, physicalResourceId=response_data['AppName'])
          def handle_delete(ev, con):
              app=ev['PhysicalResourceId']
              domain_id = ev['ResourceProperties']['DomainId']
              user_profile=ev['ResourceProperties']['UserProfileName']
              try:
                  paginator = client.get_paginator('list_apps')
                  logger.info(f'Domain {domain_id}, user {user_profile}')
                  page_iterator = paginator.paginate(DomainIdEquals=domain_id, UserProfileNameEquals=user_profile)
                  for page in page_iterator:
                      logger.info(f'Page {page}')
                      for app in page['Apps']:
                          try:
                              logger.info(f'Deleting App {app}')
                              d = False
                              while not d:
                                  response = client.describe_app(DomainId=domain_id, UserProfileName=user_profile, AppType=app['AppType'],AppName=app['AppName'])
                                  logger.info(response)
                                  if response is not None and 'Status' in response and response['Status'] == 'Deleted':
                                      d = True
                                  elif response['Status'] != 'Deleting':
                                      client.delete_app(DomainId=domain_id,UserProfileName=user_profile,AppType=app['AppType'],AppName=app['AppName'])
                                  time.sleep(5)
                          except Exception:
                              pass
                  cfnresponse.send(ev, con, cfnresponse.SUCCESS, {}, physicalResourceId=app)
              except Exception as exp:
                  logger.exception(exp)
                  cfnresponse.send(ev, con,cfnresponse.SUCCESS, {}, physicalResourceId=app)

          def create_app(config):
              domain_id = config['DomainId']
              user_profile_name = config['UserProfileName']
              app_name = config['AppName']
              app_type = config['AppType']
              response = client.create_app(DomainId=domain_id, UserProfileName=user_profile_name,  AppType=app_type, AppName=app_name)
              created = False
              while not created:
                  response = client.describe_app(DomainId=domain_id, UserProfileName=user_profile_name, AppType=app_type, AppName=app_name)
                  time.sleep(5)
                  if response['Status'] == 'InService':
                      created=True
              return response
      Timeout: 900
    DependsOn:
      - LambdaExecutionPolicy

  DownloadNotebooksFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Code: 
        ZipFile: | 
          import json, os, time, sys, traceback, logging
          import boto3
          import cfnresponse

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def fix_files(local):
            for dirpath, dirnames, files in os.walk(local, topdown=False):
              for file_name in files:
                fn = os.path.join(dirpath, file_name)
                f_stat = os.stat(fn)
                if f_stat.st_uid == 0:
                  os.chown(fn, 200005, 1001) 
              d_stat = os.stat(dirpath)
              if d_stat.st_uid == 0:
                os.chown(dirpath, 200005, 1001) 

          def download_dir(prefix, local, bucket, region):
              client = boto3.client('s3', region_name='us-west-2')
              paginator = client.get_paginator('list_objects')
              operation_parameters = {'Bucket': bucket, 'Prefix': prefix}
              keys = []
              dirs = []
              page_iterator = paginator.paginate(**operation_parameters)

              for page in page_iterator:
                  for content in page['Contents']:
                      k = content['Key']
                      if k[-1] != '/':
                          keys.append(k)
                      else:
                          dirs.append(k)
              for d in dirs:
                  dest_pathname = os.path.join(local, d).replace(prefix, '')
                  if not os.path.exists(os.path.dirname(dest_pathname)):
                      os.makedirs(os.path.dirname(dest_pathname), mode=0o777)
              for k in keys:
                  dest_pathname = os.path.join(local, k)
                  dest_pathname = dest_pathname.replace(prefix, '')
                  if not os.path.exists(os.path.dirname(dest_pathname)):
                      os.makedirs(os.path.dirname(dest_pathname), mode=0o777)
                  client.download_file(bucket, k, dest_pathname)
              fix_files(local)

          def handle_create(event, context):
              resource_config = event['ResourceProperties']
              prefix = resource_config['Prefix']
              target = resource_config['Target']
              bucket = resource_config['S3Bucket']
              region = resource_config['BucketRegion']
              logger.info(f'calling download_dir {prefix}, {target}, {bucket}, {region}')
              download_dir(prefix, target, bucket, region)

          def lambda_handler(event, context):
              logger.info(f'event: {event}')
              try:
                  if event['RequestType'] == 'Create':
                      handle_create(event, context)
                      cfnresponse.send(event, context, cfnresponse.SUCCESS,{}, physicalResourceId='12345678')
                  elif event['RequestType'] == 'Delete':
                      time.sleep(5)
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {},physicalResourceId=event['PhysicalResourceId'])
                  else:
                      time.sleep(5)
                      cfnresponse.send(event, context, cfnresponse.SUCCESS,{}, physicalResourceId='12345678')
              except Exception as exp:
                  exception_type, exception_value, exception_traceback = sys.exc_info()
                  traceback_string = traceback.format_exception(exception_type, exception_value, exception_traceback)
                  err_msg = json.dumps({"errorType": exception_type.__name__,"errorMessage": str(exception_value), "stackTrace": traceback_string})
                  logger.error(err_msg)
                  cfnresponse.send(event, context, cfnresponse.FAILED,{}, reason=str(exp))


      Description: Copies notebook files into EFS filesystem created by studio
      FileSystemConfigs:
        - Arn: !GetAtt LabEFS.Arn
          LocalMountPath: '/mnt/studio'
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.8
      Timeout: 300
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSG
          - !GetAtt StudioDomain.SG
        SubnetIds:
          - !Ref PrivateSubnet
  
  StudioDomain:
    Type: Custom::StudioDomain
    Properties:
      ServiceToken: !GetAtt StudioDomainFunction.Arn
      VPC: !Ref VPC
      SubnetIds: !Ref PublicSubnet
      DomainName: "MyDomainName"
      DefaultUserSettings:
        ExecutionRole: !GetAtt SageMakerExecutionRole.Arn

  UserProfile:
    Type: Custom::UserProfile
    Properties:
      ServiceToken: !GetAtt UserProfileFunction.Arn
      DomainId: !GetAtt StudioDomain.DomainId
      UserProfileName: !Ref UserProfileName
      UserSettings:
        ExecutionRole: !GetAtt SageMakerExecutionRole.Arn

  DefaultApp:
    Type: Custom::App
    Properties:
      ServiceToken: !GetAtt AppFunction.Arn
      DomainId: !GetAtt StudioDomain.DomainId
      UserProfileName: !GetAtt UserProfile.UserProfileName
      AppName: default
      AppType: JupyterServer
      UserSettings:
        ExecutionRole: !GetAtt SageMakerExecutionRole.Arn

  CopyNotebooks:
    Type: Custom::DownloadNotebooksFunction
    Properties:
      ServiceToken: !GetAtt DownloadNotebooksFunction.Arn
      Prefix: ''
      Target: '/mnt/studio/200005'
      S3Bucket: 'deeplearning-ai-aws-specialization'
      BucketRegion: 'us-east-1'
    DependsOn:
      - DefaultApp
      - NAT
      - PrivateSubnetRouteTableAssociation
      - PublicSubnet1RouteTableAssociation
      - PublicRoute1
      - Route

  LabBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Join ["-", ["sagemaker-us-east-1", !Ref "AWS::AccountId"]]

  LabEFS:
    Type: "AWS::EFS::AccessPoint"
    Properties:
      ClientToken: !GetAtt StudioDomain.DomainId
      FileSystemId: !GetAtt StudioDomain.EFSId
      PosixUser:
        Gid: "0"
        Uid: "0"

  LambdaSG:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupDescription: Allow Lambda outbound traffic
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      VpcId: !Ref VPC

Outputs:
  LabAccountId:
    Value: !Ref "AWS::AccountId"
  LabRegion:
    Value: !Ref "AWS::Region"
  LabBucket:
    Value: !Ref "LabBucket"

